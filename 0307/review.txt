////////////////////////////
1244
순열


nPr = n * n-1Pr-1

최대자리수 n, 최대교환횟수 r
n < r인 상태
초과한 정도의 홀짝 여부에 따라 r을 n과 n-1로 변경

재귀 버전 순열 알고리즘


현재 작성한 코드는 greedy 요소가 들어있다.
순열을 사용하지 않음

그리디 조건이 미비할 수 있음
size 호출이 계속 반복됨
num[i] - '0' 이 계속 반복됨

priority 이용 방식

/////////////////////////////
1265
중복조합
시간초과 원인 제거 필요
100!는 계산 불가한 시간

nHr = nHr-1 + n-1Hr     r <= nHr
nHr = n+r-1Cr

O(n!) = O(100!)


nHr(n/p + 1, p, p)

1266
독립시행확률

연산과정 중 소수점 반올림의 경우 
x100 후 /100같은 방식 이용

소수는 7개, 소수 아닌것은 11개
따라서 소수일 확률을 구하는 것이 더 빠르다.

nCr을 점화식으로 구하면 시간 손해
nCr = nPr / r!
-> 
for(int i = 1; i <= r; i++)
    q = q * n-- / i;

nCr 구하는 속도 순위
1. dp 테이블 이용 : [0][0] 부터 순서대로 채움
2. 동시 계산
3. nPr / r!
4. nCr 점화식


